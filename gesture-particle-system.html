<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture-Based Particle System + Gemini AI</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- MediaPipe (Global Scripts) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        
        /* Glassmorphism Utilities */
        .glass {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
        }

        /* Loading Spinner */
        .loader {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #4f46e5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Video Flip */
        #input_video { transform: scaleX(-1); }
    </style>
</head>
<body class="text-white">

    <!-- Loading Overlay -->
    <div id="loading-screen" class="fixed inset-0 z-50 flex flex-col items-center justify-center bg-black transition-opacity duration-500">
        <div class="loader mb-4"></div>
        <h2 class="text-xl font-light tracking-widest text-indigo-400">INITIALIZING SYSTEMS</h2>
        <p class="text-xs text-gray-500 mt-2">Loading Models & Fonts...</p>
        <!-- Failsafe Close Button -->
        <button onclick="document.getElementById('loading-screen').style.display='none'" class="mt-8 text-[10px] text-gray-700 hover:text-gray-400 underline">
            Force Close Loader
        </button>
    </div>

    <!-- UI Overlay -->
    <div class="fixed top-0 left-0 w-full h-full pointer-events-none z-10 p-6 flex flex-col justify-between">
        
        <!-- Header -->
        <div class="flex justify-between items-start pointer-events-auto">
            <div class="glass rounded-xl p-4 max-w-xs">
                <h1 class="text-lg font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500">
                    Particle Gestures
                </h1>
                <p class="text-xs text-gray-300 mt-1">
                    ‚úä Fist: Saturn<br>
                    ‚úåÔ∏è V-Sign: "Hello"<br>
                    ü§å Finger Heart: Heart<br>
                    üñê Open Hand: Rainbow Sphere
                </p>
                <div class="mt-2 text-xs font-mono text-indigo-300">
                    Status: <span id="gesture-status">Waiting for hand...</span>
                </div>
            </div>

            <!-- Webcam Preview -->
            <div class="glass rounded-xl overflow-hidden relative w-48 h-36">
                <video id="input_video" class="w-full h-full object-cover" autoplay playsinline muted></video>
                <div class="absolute bottom-1 right-2 text-[10px] bg-black/50 px-1 rounded">CAM</div>
            </div>
        </div>

        <!-- Controls -->
        <div class="flex justify-between items-end pointer-events-auto">
            <div class="glass rounded-xl p-3 flex gap-3 items-center">
                <button id="btn-magic" class="bg-gradient-to-r from-pink-500 to-violet-600 hover:from-pink-600 hover:to-violet-700 text-white text-sm font-bold py-2 px-4 rounded-lg shadow-lg transition-all transform hover:scale-105">
                    ‚ú® AI Magic
                </button>
                <div class="h-6 w-px bg-white/20"></div>
                <input type="color" id="color-picker" value="#ffffff" class="w-8 h-8 rounded cursor-pointer bg-transparent border-none">
            </div>
            
            <button id="btn-fullscreen" class="glass p-3 rounded-xl hover:bg-white/10 transition">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 4l-5-5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
                </svg>
            </button>
        </div>
    </div>

    <!-- AI Modal -->
    <div id="ai-modal" class="fixed inset-0 z-40 bg-black/80 backdrop-blur-sm hidden flex items-center justify-center">
        <div class="glass p-6 rounded-2xl w-full max-w-md mx-4 shadow-2xl border border-indigo-500/30">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-400 to-indigo-400">Gemini Particle Generator</h3>
                <button id="close-modal" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            
            <label class="block text-xs text-gray-400 mb-1">Google Gemini API Key</label>
            <input type="password" id="api-key" placeholder="Enter API Key here..." class="w-full bg-black/40 border border-gray-600 rounded p-2 mb-4 text-sm focus:border-indigo-500 outline-none text-white">
            
            <label class="block text-xs text-gray-400 mb-1">Describe a shape (e.g., "Spiral DNA", "Tornado")</label>
            <textarea id="ai-prompt" rows="3" class="w-full bg-black/40 border border-gray-600 rounded p-2 mb-4 text-sm focus:border-indigo-500 outline-none text-white" placeholder="A swirling galaxy of stars..."></textarea>
            
            <button id="generate-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-colors flex justify-center items-center gap-2">
                <span>Generate Code</span>
            </button>
            <p id="ai-error" class="text-red-400 text-xs mt-2 hidden"></p>
        </div>
    </div>

    <!-- Main Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';
        
        // --- Configuration ---
        const PARTICLE_COUNT = 20000;
        const PARTICLE_SIZE = 0.15;
        const CAM_Z = 35;
        
        let scene, camera, renderer, composer, particles, geometry;
        let positions, colors;
        let targetPositions, targetColors;
        let currentGesture = 'None';
        let font; // Loaded font
        let isAIActive = false;

        // UI Elements
        const statusEl = document.getElementById('gesture-status');
        const loaderEl = document.getElementById('loading-screen');
        const modal = document.getElementById('ai-modal');
        const magicBtn = document.getElementById('btn-magic');
        const closeModalBtn = document.getElementById('close-modal');
        const generateBtn = document.getElementById('generate-btn');
        const apiKeyInput = document.getElementById('api-key');
        const aiPromptInput = document.getElementById('ai-prompt');
        const aiErrorEl = document.getElementById('ai-error');
        const colorPicker = document.getElementById('color-picker');

        // --- Initialization ---
        // Safety timeout to kill loader if something hangs
        setTimeout(() => {
            if(loaderEl.style.opacity !== '0') {
                console.warn("Forcing loader removal");
                loaderEl.style.opacity = '0';
                setTimeout(() => loaderEl.style.display = 'none', 500);
            }
        }, 8000);

        init();
        animate();

        async function init() {
            try {
                // 1. Three.js Setup
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = CAM_Z;

                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                document.body.appendChild(renderer.domElement);

                // 2. Post-Processing (Bloom)
                const renderScene = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0;
                bloomPass.strength = 1.2;
                bloomPass.radius = 0.5;

                composer = new EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);

                // 3. Particle System
                geometry = new THREE.BufferGeometry();
                positions = new Float32Array(PARTICLE_COUNT * 3);
                colors = new Float32Array(PARTICLE_COUNT * 3);
                targetPositions = new Float32Array(PARTICLE_COUNT * 3);
                targetColors = new Float32Array(PARTICLE_COUNT * 3);

                const color = new THREE.Color();

                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const r = 10 * Math.cbrt(Math.random());

                    const x = r * Math.sin(phi) * Math.cos(theta);
                    const y = r * Math.sin(phi) * Math.sin(theta);
                    const z = r * Math.cos(phi);

                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;

                    targetPositions[i * 3] = x;
                    targetPositions[i * 3 + 1] = y;
                    targetPositions[i * 3 + 2] = z;

                    color.setHSL(Math.random(), 0.7, 0.5);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                    
                    targetColors[i * 3] = color.r;
                    targetColors[i * 3 + 1] = color.g;
                    targetColors[i * 3 + 2] = color.b;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: PARTICLE_SIZE,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    transparent: true,
                    opacity: 0.8
                });

                particles = new THREE.Points(geometry, material);
                scene.add(particles);

                // 4. Load Font
                const loader = new FontLoader();
                try {
                    font = await Promise.race([
                        new Promise((resolve, reject) => {
                            loader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', resolve, undefined, reject);
                        }),
                        new Promise((_, reject) => setTimeout(() => reject(new Error("Font Timeout")), 5000))
                    ]);
                } catch (e) {
                    console.warn("Font loading failed or timed out. Text gestures may not work.", e);
                }

                // 5. MediaPipe Setup
                if(!window.Hands || !window.Camera) {
                    throw new Error("MediaPipe libraries failed to load.");
                }

                const videoElement = document.getElementById('input_video');
                const hands = new window.Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }});
                
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.6,
                    minTrackingConfidence: 0.5
                });

                hands.onResults(onHandsResults);

                const cam = new window.Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({image: videoElement});
                    },
                    width: 320,
                    height: 240
                });
                
                cam.start().catch(e => console.error("Camera start failed", e));

                // 6. UI Events
                setupUI();

                // HIDE LOADER
                loaderEl.style.opacity = '0';
                setTimeout(() => loaderEl.style.display = 'none', 500);

            } catch (err) {
                console.error("Initialization Error:", err);
                loaderEl.style.opacity = '0';
                setTimeout(() => loaderEl.style.display = 'none', 500);
            }
        }

        // --- UI Logic ---
        function setupUI() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });

            magicBtn.addEventListener('click', () => modal.classList.remove('hidden'));
            closeModalBtn.addEventListener('click', () => modal.classList.add('hidden'));
            
            document.getElementById('btn-fullscreen').addEventListener('click', () => {
                if (!document.fullscreenElement) document.documentElement.requestFullscreen();
                else document.exitFullscreen();
            });

            generateBtn.addEventListener('click', handleAIGeneration);
            
            colorPicker.addEventListener('input', (e) => {
                if(currentGesture === 'None') return;
                const c = new THREE.Color(e.target.value);
                for(let i=0; i<PARTICLE_COUNT; i++) {
                    targetColors[i*3] = c.r;
                    targetColors[i*3+1] = c.g;
                    targetColors[i*3+2] = c.b;
                }
            });
        }

        // --- MediaPipe Hand Logic ---
        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                detectGesture(lm);
            }
        }

        function detectGesture(landmarks) {
            if(isAIActive) return;

            const isExtended = (tipIdx, pipIdx) => landmarks[tipIdx].y < landmarks[pipIdx].y;
            
            const indexUp = isExtended(8, 6);
            const middleUp = isExtended(12, 10);
            const ringUp = isExtended(16, 14);
            const pinkyUp = isExtended(20, 18);
            
            const thumbTip = new THREE.Vector3(landmarks[4].x, landmarks[4].y, 0);
            const indexPip = new THREE.Vector3(landmarks[6].x, landmarks[6].y, 0);
            const thumbExtended = thumbTip.distanceTo(indexPip) > 0.15;

            const indexTip = new THREE.Vector3(landmarks[8].x, landmarks[8].y, 0);
            const distThumbIndex = thumbTip.distanceTo(indexTip);
            
            let newGesture = 'Unknown';

            if (distThumbIndex < 0.05 && !middleUp && !ringUp && !pinkyUp) {
                newGesture = 'Finger Heart';
            } else if (!indexUp && !middleUp && !ringUp && !pinkyUp && !thumbExtended) {
                newGesture = 'Fist';
            } else if (indexUp && middleUp && !ringUp && !pinkyUp) {
                newGesture = 'V-Sign';
            } else if (indexUp && middleUp && ringUp && pinkyUp) {
                newGesture = 'Open Hand';
            }

            if (newGesture !== currentGesture) {
                currentGesture = newGesture;
                statusEl.innerText = newGesture === 'V-Sign' ? 'Hello' : newGesture;
                updateShape(newGesture);
            }
        }

        // --- Shape Logic ---
        function updateShape(gesture) {
            const c = new THREE.Color();
            
            switch (gesture) {
                case 'Fist': // SATURN
                    for (let i = 0; i < PARTICLE_COUNT; i++) {
                        if (i < PARTICLE_COUNT * 0.7) {
                            const r = 6;
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.acos((Math.random() * 2) - 1);
                            targetPositions[i*3] = r * Math.sin(phi) * Math.cos(theta);
                            targetPositions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                            targetPositions[i*3+2] = r * Math.cos(phi);
                            c.setHex(0x2244ff);
                        } else {
                            const r = 9 + Math.random() * 4;
                            const theta = Math.random() * Math.PI * 2;
                            const x = r * Math.cos(theta);
                            const z = r * Math.sin(theta);
                            const tilt = 0.4;
                            targetPositions[i*3] = x;
                            targetPositions[i*3+1] = x * Math.sin(tilt);
                            targetPositions[i*3+2] = z * Math.cos(tilt);
                            c.setHex(0xffaa00);
                        }
                        targetColors[i*3] = c.r; targetColors[i*3+1] = c.g; targetColors[i*3+2] = c.b;
                    }
                    break;

                case 'V-Sign': // HELLO Text
                    if(!font) return;
                    // Changed color to darker blue (0x114499) to prevent white-out brightness
                    sampleText("Hello", 0x114499); 
                    break;

                case 'Finger Heart': // HEART
                    for (let i = 0; i < PARTICLE_COUNT; i++) {
                        const t = Math.random() * Math.PI * 2;
                        const scale = 0.5;
                        const x = 16 * Math.pow(Math.sin(t), 3);
                        const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                        const z = (Math.random() - 0.5) * 5;
                        targetPositions[i*3] = x * scale;
                        targetPositions[i*3+1] = y * scale;
                        targetPositions[i*3+2] = z * scale;
                        c.setHex(0xff0066);
                        targetColors[i*3] = c.r; targetColors[i*3+1] = c.g; targetColors[i*3+2] = c.b;
                    }
                    break;

                case 'Open Hand': // RAINBOW
                    for (let i = 0; i < PARTICLE_COUNT; i++) {
                        const r = 10 + Math.random() * 5;
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos((Math.random() * 2) - 1);
                        targetPositions[i*3] = r * Math.sin(phi) * Math.cos(theta);
                        targetPositions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                        targetPositions[i*3+2] = r * Math.cos(phi);
                        c.setHSL((targetPositions[i*3]/20) + 0.5, 0.8, 0.5);
                        targetColors[i*3] = c.r; targetColors[i*3+1] = c.g; targetColors[i*3+2] = c.b;
                    }
                    break;
            }
        }

        function sampleText(textStr, colorHex) {
            const textGeo = new TextGeometry(textStr, {
                font: font,
                size: 5,        // Large size for clarity
                height: 1.5,    // Thick depth
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.2,
                bevelSize: 0.1,
                bevelSegments: 5
            });

            textGeo.computeBoundingBox();
            const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
            textGeo.translate(centerOffset, 0, 0);

            const mesh = new THREE.Mesh(textGeo);
            const sampler = new MeshSurfaceSampler(mesh).build();
            const tempPos = new THREE.Vector3();
            const c = new THREE.Color(colorHex);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                sampler.sample(tempPos);
                targetPositions[i*3] = tempPos.x;
                targetPositions[i*3+1] = tempPos.y;
                targetPositions[i*3+2] = tempPos.z;

                targetColors[i*3] = c.r;
                targetColors[i*3+1] = c.g;
                targetColors[i*3+2] = c.b;
            }
        }

        // --- Gemini Integration ---
        async function handleAIGeneration() {
            const key = apiKeyInput.value;
            const promptText = aiPromptInput.value;
            aiErrorEl.classList.add('hidden');
            
            if(!key) {
                aiErrorEl.innerText = "Please enter an API Key.";
                aiErrorEl.classList.remove('hidden');
                return;
            }

            generateBtn.innerHTML = `<div class="loader" style="width:20px;height:20px;border-width:2px;"></div> Generating...`;

            const systemInstruction = `
                You are a JavaScript generator for a particle system. 
                I have arrays: targetPositions (x,y,z flat), targetColors (r,g,b flat), variable 'count' (20000), 'i' (loop index).
                Generate ONLY the JavaScript code inside the for-loop (for i=0; i<count; i++) to set targetPositions and targetColors based on the user's shape description.
                Do not include the for loop itself.
                Use 'i' as index.
                Use Math functions.
                Center the shape at 0,0,0. Scale roughly to fit in -15 to 15 range.
                Shape description: "${promptText}"
                Response format: Plain text code only. No markdown.
            `;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${key}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: systemInstruction }] }]
                    })
                });

                const data = await response.json();
                
                if(data.error) throw new Error(data.error.message);

                let code = data.candidates[0].content.parts[0].text;
                code = code.replace(/```javascript/g, '').replace(/```/g, '');

                const particleFunc = new Function('i', 'count', 'targetPositions', 'targetColors', 'Math', code);

                for(let i=0; i<PARTICLE_COUNT; i++) {
                    particleFunc(i, PARTICLE_COUNT, targetPositions, targetColors, Math);
                }

                isAIActive = true;
                currentGesture = 'AI Generated';
                statusEl.innerText = `AI: ${promptText}`;
                modal.classList.add('hidden');

            } catch (err) {
                console.error(err);
                aiErrorEl.innerText = "Error: " + err.message;
                aiErrorEl.classList.remove('hidden');
            } finally {
                generateBtn.innerHTML = `<span>Generate Code</span>`;
            }
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const lerpFactor = 0.08;
            const positionsAttribute = geometry.attributes.position;
            const colorsAttribute = geometry.attributes.color;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                positions[i*3] += (targetPositions[i*3] - positions[i*3]) * lerpFactor;
                positions[i*3+1] += (targetPositions[i*3+1] - positions[i*3+1]) * lerpFactor;
                positions[i*3+2] += (targetPositions[i*3+2] - positions[i*3+2]) * lerpFactor;

                colors[i*3] += (targetColors[i*3] - colors[i*3]) * lerpFactor;
                colors[i*3+1] += (targetColors[i*3+1] - colors[i*3+1]) * lerpFactor;
                colors[i*3+2] += (targetColors[i*3+2] - colors[i*3+2]) * lerpFactor;
            }

            positionsAttribute.needsUpdate = true;
            colorsAttribute.needsUpdate = true;
            particles.rotation.y += 0.002;

            composer.render();
        }
    </script>
</body>
</html>
